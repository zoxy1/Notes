// простое создание коллекции с помощью метода Arrays.asList()
arrayList.addAll(Arrays.asList(new String("text1"), new String("text1"))); 
// для сортировки коллекции переопределяем метод compare()
arrayList.sort(new Comparator<String>() {
	@override
	public int compare(String stringOne, String stringTwo) {
		return stringOne.compareTo(stringTwo); 
		// если равны возращаем 0, 
		// stringOne>stringTwo возращаем 1,  
		// stringOne<stringTwo возращаем -1
	}
}

// Сортировку можно сделать только в коллекциях типа List и TreeSet, в HashSet(внутри реализован на базе HashMap) нельзя тк порядок не гарантируется
// сортировку можно сделать если реализовать у сортируемых обьектов интерфейс Comparable и
// переопределив метод compareTo(), пример:
class User implements Comparable <User> {
private final String name;
	User(String name) {
		this.name = name;
	}
	@Override
	public int compareTo(User o) {
		return this.name.compareTo(o.name);
	}
}

HashMap
1. HashMap представляет из себя массив записей (Map.Entry<K,V>)
2. Проверяется, не превысит ли порог количества элементов добавление нового. Порог (threshold) определяется как capacity * loadFactor. Если превышает, то капасити (т.е. массив записей) увеличивается, соответственно все хранящиеся значения заново добавляются в хэшмэп.
3. При добавлении новой записи <ключ, значение>, вычисляется хэшкод ключа.
4. По хэшкоду ключа находится номер элемента массива записей, в которой следует поместить новое значение.
5. Если в этом элементе уже располагается какая-то запись, то существует 2 варианта: либо ключ совпадает, тогда следует заменить значение, любо совпал хэшкод (произошла коллизия), тогда элементом этого массива устанавливается новая запись, у которой есть поле, ссылающееся на старую запись. Таким образом, в следующий раз для просмотра записей в этом элементе необходимо будет пройти связанный список записей <ключ, значение>. 